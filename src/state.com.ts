/*
 * Finite state machine library
 * Copyright (c) 2014-5 Steelbreeze Limited
 * Licensed under the MIT and GPL v3 licences
 * http://www.steelbreeze.net/state.cs
 */

/**
 * Declaration callbacks that provide transition guard conditions.
 * @interface Guard
 * @param {any} message The message that may trigger the transition.
 * @param {IActiveStateConfiguration} instance The state machine instance.
 * @param {boolean} history Internal use only
 * @returns {boolean} True if the guard condition passed.
 */
export interface Guard {
	(message?: any, instance?: IActiveStateConfiguration): boolean;
}

/**
 * Declaration for callbacks that provide state entry, state exit and transition behaviour.
 * @interface Action
 * @param {any} message The message that may trigger the transition.
 * @param {IActiveStateConfiguration} instance The state machine instance.
 * @param {boolean} history Internal use only
 * @returns {any} Actions can return any value.
 */
export interface Action {
	(message?: any, instance?: IActiveStateConfiguration, history?: boolean): any;
}

/**
 * Declaration for an array of actions.
 */
export interface Behavior extends Array<Action> { }
	
/**
 * An enumeration of static constants that dictates the precise behaviour of pseudo states.
 *
 * Use these constants as the `kind` parameter when creating new `PseudoState` instances.
 * @class PseudoStateKind
 */
export enum PseudoStateKind {		
	/**
	 * Used for pseudo states that are always the staring point when entering their parent region.
	 * @member {number} Initial
	 */
	Initial,
			
	/**
	 * Used for pseudo states that are the the starting point when entering their parent region for the first time; subsequent entries will start at the last known state.
	 * @member {number} ShallowHistory
	 */
	ShallowHistory,
	
	/**
	 * As per `ShallowHistory` but the history semantic cascades through all child regions irrespective of their initial pseudo state kind.
	 * @member {number} DeepHistory
	 */
	DeepHistory,
	
	/**
	 * Enables a dynamic conditional branches; within a compound transition.
	 * All outbound transition guards from a Choice are evaluated upon entering the PseudoState:
	 * if a single transition is found, it will be traversed;
	 * if many transitions are found, an arbitary one will be selected and traversed;
	 * if none evaluate true, and there is no 'else transition' defined, the machine is deemed illformed and an exception will be thrown.
	 * @member {number} Choice
	 */
	Choice,

	/**
	 * Enables a static conditional branches; within a compound transition.
	 * All outbound transition guards from a Choice are evaluated upon entering the PseudoState:
	 * if a single transition is found, it will be traversed;
	 * if many or none evaluate true, and there is no 'else transition' defined, the machine is deemed illformed and an exception will be thrown.
	 * @member {number} Junction
	 */
	Junction,

	/**
	 * Entering a terminate `PseudoState` implies that the execution of this state machine by means of its state object is terminated.
	 * @member {number} Terminate
	 */
	Terminate
}	

/**
 * An abstract class used as the base for the Region and Vertex classes.
 * An element is any part of the tree structure that represents a composite state machine model.
 * @class Element
 */
export class Element {
	/**
	 * The symbol used to separate element names within a fully qualified name.
	 * Change this static member to create different styles of qualified name generated by the toString method.
	 * @member {string}
	 */
	public static namespaceSeparator = ".";
	
	/**
	 * The name of the element.
	 * @member {string}
	 */
	public name: string;
	
	/**
	 * The fully qualified name of the element.
	 * @member {string}
	 */
	public qualifiedName: string;

	/**
	 * Creates a new instance of the element class.
	 * @param {string} name The name of the element.
	 */
	public constructor(name: string) {
		this.name = name;
	}

	/**
	 * Returns the parent element of this element.
	 * @method getParent
	 * @returns {Element} The parent element of the element.
	 */
	public getParent(): Element {
		return;
	 }

	/**
	 * Returns the root element within the state machine model.
	 * @method root
	 * @returns {StateMachine} The root state machine element.
	 */
	public root(): StateMachine {
		return this.getParent().root();
	}

	// The ancestors are returned as an array of elements, staring with the root element and ending with this elemenet.
	ancestors(): Array<Element> {
		return (this.getParent() ? this.getParent().ancestors() : []).concat(this);
	}

	/**
	 * Accepts an instance of a visitor.
	 * @method accept
	 * @param {Visitor<TArg>} visitor The visitor instance.
	 * @param {TArg} arg An optional argument to pass into the visitor.
	 * @returns {any} Any value can be returned by the visitor.
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any { /* virtual method */ }

	/**
	 * Returns a the element name as a fully qualified namespace.
	 * @method toString
	 * @returns {string}
	 */
	public toString(): string {
		return this.qualifiedName;
	}
}

/**
 * An element within a state machine model that is a container of Vertices.
 * 
 * Regions are implicitly inserted into composite state machines as a container for vertices.
 * They only need to be explicitly defined if orthogonal states are required.
 * 
 * Region extends the Element class and inherits its public interface.
 * @class Region
 * @augments Element
 */
export class Region extends Element {
	/**
	 * The name given to regions that are are created automatically when a state is passed as a vertex's parent.
	 * Regions are automatically inserted into state machine models as the composite structure is built; they are named using this static member.
	 * Update this static member to use a different name for default regions.
	 * @member {string} 
	 */
	public static defaultName: string = "default";
	
	/**
	 * The parent state of this region.
	 * @member {Region}
	 */
	public state: State;
	
	/**
	 * The set of vertices that are children of the region.
	 * @member {Array<Vertex>}
	 */
	public vertices: Array<Vertex> = [];
	
	/**
	 * The pseudo state that will be in initial starting state when entering the region explicitly.
	 * @member {PseudoState}
	 */
	public initial: PseudoState;

	/**
	 * Creates a new instance of the Region class.
	 * @param {string} name The name of the region.
	 * @param {State} state The parent state that this region will be a child of.
	 */
	public constructor(name: string, state: State) {
		super(name);
	
		this.state = state;

		this.state.regions.push(this);

		this.state.root().clean = false;
	}

	/**
	 * Returns the parent element of this region.
	 * @method getParent
	 * @returns {Element} The parent element of the region.
	 */
	public getParent(): Element {
		return this.state;
	}
	
	/**
	 * Accepts an instance of a visitor and calls the visitRegion method on it.
	 * @method accept
	 * @param {Visitor<TArg1>} visitor The visitor instance.
	 * @param {TArg1} arg1 An optional argument to pass into the visitor.
	 * @param {any} arg2 An optional argument to pass into the visitor.
	 * @param {any} arg3 An optional argument to pass into the visitor.
	 * @param {any} arg4 An optional argument to pass into the visitor.
	 * @returns {any} Any value can be returned by the visitor.
	 */
	public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
		return visitor.visitRegion(this, arg1, arg2, arg3, arg4);
	}
}
		
	/**
	 * An abstract element within a state machine model that can be the source or target of a transition (states and pseudo states).
	 * 
	 * Vertex extends the Element class and inherits its public interface.
	 * @class Vertex
	 * @augments Element
	 */
	export class Vertex extends Element {
		/**
		 * The parent region of this vertex.
		 * @member {Region}
		 */
		public region: Region;
		
		/**
		 * The set of transitions from this vertex.
		 * @member {Array<Transition>}
		 */
		public transitions: Array<Transition> = [];

		/**
		 * Creates a new instance of the Vertex class within a given parent region.
		 * @param {string} name The name of the vertex.
		 * @param {Region} parent The parent region.
		 */
		public constructor(name: string, parent: Region);
		
		/**
		 * Creates a new instance of the Vertex class within a given parent state.
		 * Note, this will create the vertex within the parent states default region.
		 * @param {string} name The name of the vertex.
		 * @param {State} parent The parent state.
		 */
		public constructor(name: string, parent: State);

		/**
		 * Creates a new instance of the Vertex class.
		 * @param {string} name The name of the vertex.
		 * @param {Region|State} parent The parent region or state.
		 */
		public constructor(name: string, parent: any) {
			super(name);

			if (parent instanceof Region) {
				this.region = <Region>parent;
			} else if (parent instanceof State) {
				this.region = (<State>parent).defaultRegion();
			}

			if (this.region) {
				this.region.vertices.push(this);
				this.region.root().clean = false;
			}
		}

		/**
		 * Returns the parent element of this vertex.
		 * @method getParent
		 * @returns {Element} The parent element of the vertex.
		 */
		public getParent(): Element {
			return this.region;
		}
		
		/**
		 * Creates a new transition from this vertex.
		 * Newly created transitions are completion transitions; they will be evaluated after a vertex has been entered if it is deemed to be complete.
		 * Transitions can be converted to be event triggered by adding a guard condition via the transitions `where` method.
		 * @method to
		 * @param {Vertex} target The destination of the transition; omit for internal transitions.
		 * @returns {Transition} The new transition object.
		 */
		public to(target?: Vertex): Transition {
			var transition = new Transition(this, target);

			this.transitions.push(transition);
			this.root().clean = false;

			return transition;
		}
	}
	
	/**
	 * An element within a state machine model that represents an transitory Vertex within the state machine model.
	 * 
	 * Pseudo states are required in all state machine models; at the very least, an `Initial` pseudo state is the default stating state when the parent region is entered.
	 * Other types of pseudo state are available; typically for defining history semantics or to facilitate more complex transitions.
	 * A `Terminate` pseudo state kind is also available to immediately terminate processing within the entire state machine instance.
	 *
	 * PseudoState extends the Vertex class and inherits its public interface.
	 * @class PseudoState
	 * @augments Vertex
	 */
	export class PseudoState extends Vertex {
		/**
		 * The kind of the pseudo state which determines its use and behaviour.
		 * @member {PseudoStateKind}
		 */
		public kind: PseudoStateKind;
		
		/**
		 * Creates a new instance of the PseudoState class.
		 * @param {string} name The name of the pseudo state.
		 * @param {Region} parent The parent region that this pseudo state will be a child of.
		 * @param {PseudoStateKind} kind Determines the behaviour of the PseudoState.
		 */
		public constructor(name: string, parent: Region, kind: PseudoStateKind);
		
		/**
		 * Creates a new instance of the PseudoState class.
		 * @param {string} name The name of the pseudo state.
		 * @param {State} parent The parent state that this pseudo state will be a child of.
		 * @param {PseudoStateKind} kind Determines the behaviour of the PseudoState.
		 */
		public constructor(name: string, parent: State, kind: PseudoStateKind);

		/**
		 * Creates a new instance of the PseudoState class.
		 * @param {string} name The name of the pseudo state.
		 * @param {Element} parent The parent element that this pseudo state will be a child of.
		 * @param {PseudoStateKind} kind Determines the behaviour of the PseudoState.
		 */
		public constructor(name: string, parent: any, kind: PseudoStateKind) {
			super(name, parent);

			this.kind = kind;

			if (this.isInitial()) {
				this.region.initial = this;
			}
		}

		/**
		 * Tests a pseudo state to determine if it is a history pseudo state.
		 * History pseudo states are of kind: Initial, ShallowHisory, or DeepHistory.
		 * @method isHistory
		 * @returns {boolean} True if the pseudo state is a history pseudo state.
		 */
		public isHistory(): boolean {
			return this.kind === PseudoStateKind.DeepHistory || this.kind === PseudoStateKind.ShallowHistory;
		}

		/**
		 * Tests a pseudo state to determine if it is an initial pseudo state.
		 * Initial pseudo states are of kind: Initial, ShallowHisory, or DeepHistory.
		 * @method isInitial
		 * @returns {boolean} True if the pseudo state is an initial pseudo state.
		 */
		public isInitial(): boolean {
			return this.kind === PseudoStateKind.Initial || this.isHistory();
		}

		/**
		 * Accepts an instance of a visitor and calls the visitPseudoState method on it.
		 * @method accept
		 * @param {Visitor<TArg1>} visitor The visitor instance.
		 * @param {TArg1} arg1 An optional argument to pass into the visitor.
		 * @param {any} arg2 An optional argument to pass into the visitor.
		 * @param {any} arg3 An optional argument to pass into the visitor.
		 * @param {any} arg4 An optional argument to pass into the visitor.
		 * @returns {any} Any value can be returned by the visitor.
 		 */
		public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return visitor.visitPseudoState(this, arg1, arg2, arg3, arg4);
		}
	}	
	
	/**
	 * An element within a state machine model that represents an invariant condition within the life of the state machine instance.
	 *
	 * States are one of the fundamental building blocks of the state machine model.
	 * Behaviour can be defined for both state entry and state exit.
	 *
	 * State extends the Vertex class and inherits its public interface.
	 * @class State
	 * @augments Vertex
	 */
	export class State extends Vertex {
		// user defined behaviour (via exit method) to execute when exiting a state.
		exitBehavior: Behavior = [];
		
		// user defined behaviour (via entry method) to execute when entering a state.
		entryBehavior: Behavior = [];
		
		/**
		 * The set of regions under this state.
		 * @member {Array<Region>}
		 */
		public regions: Array<Region> = [];		

		/** 
		 * Creates a new instance of the State class.
		 * @param {string} name The name of the state.
		 * @param {Region} parent The parent region that owns the state.
		 */
		public constructor(name: string, parent: Region);
		
		/** 
		 * Creates a new instance of the State class.
		 * @param {string} name The name of the state.
		 * @param {State} parent The parent state that owns the state.
		 */
		public constructor(name: string, parent: State);

		/** 
		 * Creates a new instance of the State class.
		 * @param {string} name The name of the state.
		 * @param {Element} parent The parent state that owns the state.
		 */
		public constructor(name: string, parent: any) {
			super(name, parent);
		}

		/**
		 * Returns the default region for the state.
		 * Note, this will create the default region if it does not already exist.
		 * @method defaultRegion
		 * @returns {Region} The default region.
		 */
		public defaultRegion(): Region {
			var region: Region;

			this.regions.forEach(r => { if (r.name === Region.defaultName) { region = r; } });

			if (!region) {
				region = new Region(Region.defaultName, this);
			}

			return region;
		}

		/**
		 * Tests the state to see if it is a final state;
		 * a final state is one that has no outbound transitions.
		 * @method isFinal
		 * @returns {boolean} True if the state is a final state.
		 */
		public isFinal(): boolean {
			return this.transitions.length === 0;
		}
		
		/**
		 * Tests the state to see if it is a simple state;
		 * a simple state is one that has no child regions.
		 * @method isSimple
		 * @returns {boolean} True if the state is a simple state.
		 */
		public isSimple(): boolean {
			return this.regions.length === 0;
		}

		/**
		 * Tests the state to see if it is a composite state;
		 * a composite state is one that has one or more child regions.
		 * @method isComposite
		 * @returns {boolean} True if the state is a composite state.
		 */
		public isComposite(): boolean {
			return this.regions.length > 0;
		}

		/**
		 * Tests the state to see if it is an orthogonal state;
		 * an orthogonal state is one that has two or more child regions.
		 * @method isOrthogonal
		 * @returns {boolean} True if the state is an orthogonal state.
		 */
		public isOrthogonal(): boolean {
			return this.regions.length > 1;
		}
		
		/**
		 * Adds behaviour to a state that is executed each time the state is exited.
		 * @method exit
		 * @param {Action} exitAction The action to add to the state's exit behaviour.
		 * @returns {State} Returns the state to allow a fluent style API.
		 */
		public exit<TMessage>(exitAction: Action): State {
			this.exitBehavior.push(exitAction);

			this.root().clean = false;

			return this;
		}

		/**
		 * Adds behaviour to a state that is executed each time the state is entered.
		 * @method entry
		 * @param {Action} entryAction The action to add to the state's entry behaviour.
		 * @returns {State} Returns the state to allow a fluent style API.
		 */
		public entry<TMessage>(entryAction: Action): State {
			this.entryBehavior.push(entryAction);

			this.root().clean = false;

			return this;
		}

		/**
		 * Accepts an instance of a visitor and calls the visitState method on it.
		 * @method accept
		 * @param {Visitor<TArg1>} visitor The visitor instance.
		 * @param {TArg1} arg1 An optional argument to pass into the visitor.
		 * @param {any} arg2 An optional argument to pass into the visitor.
		 * @param {any} arg3 An optional argument to pass into the visitor.
		 * @param {any} arg4 An optional argument to pass into the visitor.
		 * @returns {any} Any value can be returned by the visitor.
 		 */
		public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return visitor.visitState(this, arg1, arg2, arg3, arg4);
		}
	}	
	
	/**
	 * An element within a state machine model that represents completion of the life of the containing Region within the state machine instance.
	 *
	 * A final state cannot have outbound transitions.
	 *
	 * FinalState extends the State class and inherits its public interface.
	 * @class FinalState
	 * @augments State
	 */
	export class FinalState extends State {
		/** 
		 * Creates a new instance of the FinalState class.
		 * @param {string} name The name of the final state.
		 * @param {Region} parent The parent region that owns the final state.
		 */
		public constructor(name: string, parent: Region);
		
		/** 
		 * Creates a new instance of the FinalState class.
		 * @param {string} name The name of the final state.
		 * @param {State} parent The parent state that owns the final state.
		 */
		public constructor(name: string, parent: State);
		
		/** 
		 * Creates a new instance of the FinalState class.
		 * @param {string} name The name of the final state.
		 * @param {Element} parent The parent element that owns the final state.
		 */
		public constructor(name: string, parent: any) {
			super(name, parent);
		}

		// override Vertex.to to throw an exception when trying to create a transition from a final state.
		public to(target?: Vertex): Transition {
			throw "A FinalState cannot be the source of a transition.";
		}

		/**
		 * Accepts an instance of a visitor and calls the visitFinalState method on it.
		 * @method accept
		 * @param {Visitor<TArg>} visitor The visitor instance.
		 * @param {TArg} arg An optional argument to pass into the visitor.
		 * @returns {any} Any value can be returned by the visitor.
 		 */
		public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return visitor.visitFinalState(this, arg1, arg2, arg3, arg4);
		}
	}
	
	/**
	 * An element within a state machine model that represents the root of the state machine model.
	 *
	 * StateMachine extends the State class and inherits its public interface.
	 * @class StateMachine
	 * @augments State
	 */
	export class StateMachine extends State {
		// flag used to indicate that the state machine model has has structural changes and therefore requires initialising.
		clean = false;

		// the behaviour required to initialise state machine instances; created when initialising the state machine model.
		onInitialise: Behavior;
		
		/** 
		 * Creates a new instance of the StateMachine class.
		 * @param {string} name The name of the state machine.
		 */
		public constructor(name: string) {
			super(name, undefined);
		}

		/**
		 * Returns the root element within the state machine model.
		 * Note that if this state machine is embeded within another state machine, the ultimate root element will be returned.
		 * @method root
		 * @returns {StateMachine} The root state machine element.
		 */
		public root(): StateMachine {
			return this.region ? this.region.root() : this;
		}

		/**
		 * Accepts an instance of a visitor and calls the visitStateMachine method on it.
		 * @method accept
		 * @param {Visitor<TArg1>} visitor The visitor instance.
		 * @param {TArg1} arg1 An optional argument to pass into the visitor.
		 * @param {any} arg2 An optional argument to pass into the visitor.
		 * @param {any} arg3 An optional argument to pass into the visitor.
		 * @param {any} arg4 An optional argument to pass into the visitor.
		 * @returns {any} Any value can be returned by the visitor.
 		 */
		public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return visitor.visitStateMachine(this, arg1, arg2, arg3, arg4);
		}
	}	
	
	/**
	 * A transition between vertices (states or pseudo states) that may be traversed in response to a message.
	 *
	 * Transitions come in a variety of types:
	 * internal transitions respond to messages but do not cause a state transition, they only have behaviour;
	 * local transitions are contained within a single region therefore the source vertex is exited, the transition traversed, and the target state entered;
	 * external transitions are more complex in nature as they cross region boundaries, all elements up to but not not including the common ancestor are exited and entered.
	 *
	 * Entering a composite state will cause the entry of the child regions within the composite state; this in turn may trigger more transitions.
	 * @class Transition
	 */
	export class Transition {
		// used as the guard condition for else tranitions
		static isElse = () => { return false; };

		// guard condition for this transition.
		guard: Guard;
		
		// user defined behaviour (via effect) executed when traversing this transition.
		transitionBehavior: Behavior = [];
		
		// the collected actions to perform when traversing the transition (includes exiting states, traversal, and state entry)
		traverse: Behavior = [];

		/** 
		 * Creates a new instance of the Transition class.
		 * @param {Vertex} source The source of the transition.
		 * @param {Vertex} source The target of the transition.
		 */
		public constructor(public source: Vertex, public target?: Vertex) {
			this.guard = message => { return message === this.source; };
		}

		/**
		 * Turns a transition into an else transition.
		 *
		 * Else transitions can be used at `Junction` or `Choice` pseudo states if no other transition guards evaluate true, an Else transition if present will be traversed.
		 * @method else
		 * @returns {Transition} Returns the transition object to enable the fluent API.
		 */
		public else(): Transition {
			this.guard = Transition.isElse;

			return this;
		}

		/**
		 * Defines the guard condition for the transition.
		 * @method when
		 * @param {Guard} guard The guard condition that must evaluate true for the transition to be traversed. 
		 * @returns {Transition} Returns the transition object to enable the fluent API.
		 */
		public when(guard: Guard): Transition {
			this.guard = guard;

			return this;
		}

		/**
		 * Add behaviour to a transition.
		 * @method effect
		 * @param {Action} transitionAction The action to add to the transitions traversal behaviour.
		 * @returns {Transition} Returns the transition object to enable the fluent API.
		 */
		public effect<TMessage>(transitionAction: Action): Transition {
			this.transitionBehavior.push(transitionAction);

			this.source.root().clean = false;

			return this;
		}

		/**
		 * Accepts an instance of a visitor and calls the visitTransition method on it.
		 * @method accept
		 * @param {Visitor<TArg1>} visitor The visitor instance.
		 * @param {TArg1} arg1 An optional argument to pass into the visitor.
		 * @param {any} arg2 An optional argument to pass into the visitor.
		 * @param {any} arg3 An optional argument to pass into the visitor.
		 * @param {any} arg4 An optional argument to pass into the visitor.
		 * @returns {any} Any value can be returned by the visitor.
 		 */
		public accept<TArg1>(visitor: Visitor<TArg1>, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return visitor.visitTransition(this, arg1, arg2, arg3, arg4);
		}
	}	
	
	
	
	
	
	
	
	/**
	 * Implementation of a visitor pattern.
	 * @class Visitor
	 */
	export class Visitor<TArg1> {
		/**
		 * Visits an element within a state machine model.
		 * @method visitElement
		 * @param {Element} element the element being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitElement(element: Element, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return;
		}

		/**
		 * Visits a region within a state machine model.
		 * @method visitRegion
		 * @param {Region} region The region being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitRegion(region: Region, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			var result = this.visitElement(region, arg1, arg2, arg3, arg4);

			region.vertices.forEach(vertex => { vertex.accept(this, arg1, arg2, arg3, arg4) });

			return result;
		}

		/**
		 * Visits a vertex within a state machine model.
		 * @method visitVertex
		 * @param {Vertex} vertex The vertex being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitVertex(vertex: Vertex, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			var result = this.visitElement(vertex, arg1, arg2, arg3, arg4);

			vertex.transitions.forEach(transition => { transition.accept(this, arg1, arg2, arg3, arg4) });

			return result;
		}

		/**
		 * Visits a pseudo state within a state machine model.
		 * @method visitPseudoState
		 * @param {PseudoState} pseudoState The pseudo state being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitPseudoState(pseudoState: PseudoState, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return this.visitVertex(pseudoState, arg1, arg2, arg3, arg4);
		}


		/**
		 * Visits a state within a state machine model.
		 * @method visitState
		 * @param {State} state The state being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitState(state: State, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			var result = this.visitVertex(state, arg1, arg2, arg3, arg4);

			state.regions.forEach(region => { region.accept(this, arg1, arg2, arg3, arg4) });
			
			return result;
		}

		/**
		 * Visits a final state within a state machine model.
		 * @method visitFinal
		 * @param {FinalState} finalState The final state being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitFinalState(finalState: FinalState, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return this.visitState(finalState, arg1, arg2, arg3, arg4);
		}

		/**
		 * Visits a state machine within a state machine model.
		 * @method visitVertex
		 * @param {StateMachine} state machine The state machine being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitStateMachine(stateMachine: StateMachine, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return this.visitState(stateMachine, arg1, arg2, arg3, arg4);
		}

		/**
		 * Visits a transition within a state machine model.
		 * @method visitTransition
		 * @param {Transition} transition The transition being visited.
		 * @param {TArg1} arg1 An optional parameter passed into the accept method.
		 * @param {any} arg2 An optional parameter passed into the accept method.
		 * @param {any} arg3 An optional parameter passed into the accept method.
		 * @param {any} arg4 An optional parameter passed into the accept method.
		 * @returns {any} Any value may be returned when visiting an element.
		 */
		public visitTransition(transition: Transition, arg1?: TArg1, arg2?: any, arg3?: any, arg4?: any): any {
			return;
		}
	}

	
	



	
	
	
	/**
	 * Interface for the state machine instance; an object used as each instance of a state machine (as the classes in this library describe a state machine model).
	 * @interface IActiveStateConfiguration
	 */
	export interface IActiveStateConfiguration {		
		/**
		 * @member {boolean} isTerminated Indicates that the state machine instance has reached a terminate pseudo state and therfore will no longer evaluate messages.
		 */
		isTerminated: boolean;

		/**
		 * Updates the last known state for a given region.
		 * @method setCurrent
		 * @param {Region} region The region to update the last known state for.
		 * @param {State} state The last known state for the given region.
		 */
		setCurrent(region: Region, state: State): void;

		/**
		 * Returns the last known state for a given region.
		 * @method getCurrent
		 * @param {Region} region The region to update the last known state for.
		 * @returns {State} The last known state for the given region.
		 */
		getCurrent(region: Region): State;
	}
	
	/**
	 * Default working implementation of a state machine instance class.
	 *
	 * Implements the `IActiveStateConfiguration` interface.
	 * It is possible to create other custom instance classes to manage state machine state in any way (e.g. as serialisable JSON); just implement the same members and methods as this class.
	 * @class StateMachineInstance
	 * @implements IActiveStateConfiguration
	 */
	export class StateMachineInstance implements IActiveStateConfiguration {
		private last: any = {};

		/**
		 * Indicates that the state manchine instance reached was terminated by reaching a Terminate pseudo state.
		 * @member isTerminated
		 */
		public isTerminated: boolean = false;

		/**
		 * Creates a new instance of the state machine instance class.
		 * @param {string} name The optional name of the state machine instance.
		 */
		public constructor(public name: string = "unnamed") { }
		
		// Updates the last known state for a given region.
		setCurrent(region: Region, state: State): void {
			this.last[region.qualifiedName] = state;
		}

		// Returns the last known state for a given region.
		getCurrent(region: Region): State {
			return this.last[region.qualifiedName];
		}

		/**
		 * Returns the name of the state machine instance.
		 * @method toString
		 * @returns {string} The name of the state machine instance.
		 */
		toString(): string {
			return this.name;
		}
	}	
	
	
	
	
	
	
	
	
	
	/**
	 * Initialises a state machine and/or state machine model.
	 * 
	 * Passing just the state machine model will initialise the model, passing the model and instance will initialse the instance and if necessary, the model.
	 * @function initialise
	 * @param {StateMachine} stateMachineModel The state machine model. If autoInitialiseModel is true (or no instance is specified) and the model has changed, the model will be initialised.
	 * @param {IActiveStateConfiguration} stateMachineInstance The optional state machine instance to initialise.
	 * @param {boolean} autoInitialiseModel Defaulting to true, this will cause the model to be initialised prior to initialising the instance if the model has changed.
	 */
	export function initialise(stateMachineModel: StateMachine, stateMachineInstance?: IActiveStateConfiguration, autoInitialiseModel: boolean = true): void {
		// initialise a state machine instance
		if (stateMachineInstance) {
			// initialise the state machine model if necessary
			if (autoInitialiseModel && stateMachineModel.clean === false) {
				initialise(stateMachineModel);
			}

			// enter the state machine instance for the first time
			invoke(stateMachineModel.onInitialise, undefined, stateMachineInstance);

		// initiaise a state machine model
		} else {
			stateMachineModel.accept(new InitialiseElements(), false);
			stateMachineModel.clean = true;
		}
	}

	/**
	 * Passes a message to a state machine for evaluation; messages trigger state transitions.
	 * @function evaluate
	 * @param {StateMachine} stateMachineModel The state machine model. If autoInitialiseModel is true (or no instance is specified) and the model has changed, the model will be initialised.
	 * @param {IActiveStateConfiguration} stateMachineInstance The instance of the state machine model to evaluate the message against.
	 * @param {boolean} autoInitialiseModel Defaulting to true, this will cause the model to be initialised prior to initialising the instance if the model has changed.
	 * @returns {boolean} True if the message triggered a state transition.
	 */
	export function evaluate(stateMachineModel: StateMachine, stateMachineInstance: IActiveStateConfiguration, message: any, autoInitialiseModel: boolean = true): boolean {
		// initialise the state machine model if necessary
		if (autoInitialiseModel && stateMachineModel.clean === false) {
			initialise(stateMachineModel);
		}

		// terminated state machine instances will not evaluate messages
		if (stateMachineInstance.isTerminated) {
			return false;
		}

		// evaluate the message using the Evaluator visitor
		return stateMachineModel.accept(Evaluator.instance, stateMachineInstance, message);
	}

	/**
	 * Tests a state machine instance to see if its lifecycle is complete. A state machine instance is complete if all regions belonging to the state machine root have curent states that are final states.
	 * @function isComplete
	 * @param {StateMachine} stateMachineModel The state machine model. 
	 * @param {IActiveStateConfiguration} stateMachineInstance The instance of the state machine model to test for completeness.
	 * @returns {boolean} True if the state machine instance is complete.
	 */
	export function isComplete(vertex: Vertex, stateMachineInstance: IActiveStateConfiguration): boolean {
		if (vertex instanceof State) {
			return (<State>vertex).regions.every(region => { return stateMachineInstance.getCurrent(region).isFinal(); });
		}

		return true;
	}

	// Temporary structure to hold element behaviour during the bootstrap process
	class ElementBehavior {
		leave: Behavior = [];
		beginEnter: Behavior = [];
		endEnter: Behavior = [];
		enter: Behavior = [];
	}

	// invokes behaviour
	function invoke(behavior: Behavior, message: any, stateMachineInstance: IActiveStateConfiguration, history: boolean = false): void {
		behavior.forEach(action => { action(message, stateMachineInstance, history) });
	}
	
	// determines if a state is currently active
	function isActive(state: State, stateMachineInstance: IActiveStateConfiguration): boolean {
		return state.region ? (isActive(state.region.state, stateMachineInstance) && (stateMachineInstance.getCurrent(state.region) === state)) : true;
	}
	
	// evaluates messages against a state machine, executing transitions as appropriate
	class Evaluator extends Visitor<IActiveStateConfiguration> {
		static instance = new Evaluator();

		visitRegion(region: Region, stateMachineInstance: IActiveStateConfiguration, message: any): boolean {
			return stateMachineInstance.getCurrent(region).accept(this, stateMachineInstance, message);
		}

		visitPseudoState(pseudoState: PseudoState, stateMachineInstance: IActiveStateConfiguration, message: any): boolean {
			var transition: Transition;

			switch (pseudoState.kind) {
				case PseudoStateKind.Initial:
				case PseudoStateKind.DeepHistory:
				case PseudoStateKind.ShallowHistory: 
					if (pseudoState.transitions.length === 1) {
						transition = pseudoState.transitions[0];
					} else {
						throw "Initial transition must have a single outbound transition from " + pseudoState;
					}

					break;

				case PseudoStateKind.Junction:
					var result: Transition, elseResult: Transition;

					pseudoState.transitions.forEach(t=> {
						if (t.guard === Transition.isElse) {
							if (elseResult) {
								throw "Multiple outbound transitions evaluated true";
							}

							elseResult = t;
						} else if (t.guard(message, stateMachineInstance)) {
							if (result) {
								throw "Multiple outbound transitions evaluated true";
							}

							result = t;
						}
					});

					transition = result || elseResult;

					break;

				case PseudoStateKind.Choice:
					var results: Array<Transition> = [];

					pseudoState.transitions.forEach(t => {
						if (t.guard === Transition.isElse) {
							if (elseResult) {
								throw "Multiple outbound else transitions found at " + this + " for " + message;
							}

							elseResult = t;
						} else if (t.guard(message, stateMachineInstance)) {
							results.push(t);
						}
					});

					transition = results.length !== 0 ? results[Math.round((results.length - 1) * Math.random())] : elseResult;

					break;
			}

			if (!transition) {
				return false;
			}

			invoke(transition.traverse, message, stateMachineInstance);

			return true;
		}

		visitState(state: State, stateMachineInstance: IActiveStateConfiguration, message: any): boolean {
			var result = false;
			
			// delegate to child regions first
			for (var i = 0, l = state.regions.length; i < l; i++) { // NOTE: use of break means this needs to stay as a for loop
				if (state.regions[i].accept(this, stateMachineInstance, message)) {				
					result = true;

					if (!isActive(state, stateMachineInstance)) {
						break;
					}
				}
			}
			
			//if still unprocessed, try to find one here
			if (!result) {
				var transition: Transition;

				state.transitions.forEach(t => {
					if (t.guard(message, stateMachineInstance)) {
						if (transition) {
							throw new Error("Multiple outbound transitions evaluated true");
						}

						transition = t;
					}
				});

				if (transition) {
					invoke(transition.traverse, message, stateMachineInstance);

					result = true;
				}
			}

			// if a transition occured, check for completions
			if (result && (message !== state) && isComplete(state, stateMachineInstance)) {
				this.visitState(state, stateMachineInstance, state);
			}

			return result;
		}
	}

	// Bootstraps transitions after all elements have been bootstrapped
	class InitialiseTransitions extends Visitor<(element: Element) => ElementBehavior> {
		visitTransition(transition: Transition, behaviour: (element: Element) => ElementBehavior) {
			// internal transitions: just perform the actions; no exiting or entering states
			if (!transition.target) {
				transition.traverse = transition.transitionBehavior;
				
				// local transtions (within the same parent region): simple exit, transition and entry
			} else if (transition.target.region === transition.source.region) {
				transition.traverse = behaviour(transition.source).leave.concat(transition.transitionBehavior).concat(behaviour(transition.target).enter);
				
				// external transitions (crossing region boundaries): exit to the LCA, transition, enter from the LCA
			} else {
				var sourceAncestors = transition.source.ancestors();
				var targetAncestors = transition.target.ancestors();
				var sourceAncestorsLength = sourceAncestors.length;
				var targetAncestorsLength = targetAncestors.length;
				var i = 0, l = Math.min(sourceAncestorsLength, targetAncestorsLength);

				// find the index of the first uncommon ancestor
				while ((i < l) && (sourceAncestors[i] === targetAncestors[i])) {
					i++;
				}

				// validate transition does not cross sibling regions boundaries
				if (sourceAncestors[i] instanceof Region) {
					throw "Transitions may not cross sibling orthogonal region boundaries";
				}
				
				// leave the first uncommon ancestor
				transition.traverse = behaviour(i < sourceAncestorsLength ? sourceAncestors[i] : transition.source).leave.slice(0);

				// perform the transition action
				transition.traverse = transition.traverse.concat(transition.transitionBehavior);

				if (i >= targetAncestorsLength) {
					transition.traverse = transition.traverse.concat(behaviour(transition.target).beginEnter);
				}
								
				// enter the target ancestry
				while (i < targetAncestorsLength) {
					var element = targetAncestors[i++];
					var next = i < targetAncestorsLength ? targetAncestors[i] : undefined;

					transition.traverse = transition.traverse.concat(behaviour(element).beginEnter);

					if (element instanceof State) {
						var state = <State>element;

						if (state.isOrthogonal()) {
							state.regions.forEach(region => { if (region !== next) { transition.traverse = transition.traverse.concat(behaviour(region).enter); } });
						}
					}
				}

				// trigger cascade
				transition.traverse = transition.traverse.concat(behaviour(transition.target).endEnter);
			}
		}
	}

	// bootstraps all the elements within a state machine model
	class InitialiseElements extends Visitor<boolean> {
		private behaviours: any = {};

		// returns the behavior for a given element; creates one if not present
		private behaviour(element: Element): ElementBehavior {
			if (!element.qualifiedName) {
				element.qualifiedName = element.ancestors().map<string>((e) => { return e.name; }).join(Element.namespaceSeparator);
			}

			return this.behaviours[element.qualifiedName] || (this.behaviours[element.qualifiedName] = new ElementBehavior());
		}

		// uncomment this method for debugging purposes
		//visitElement(element: Element, deepHistoryAbove: boolean) {
		//	var elementBehaviour = this.behaviour(element);
		//	elementBehaviour.leave.push((message, instance) => { console.log(instance + " leave " + element); });
		//	elementBehaviour.beginEnter.push((message, instance) => { console.log(instance + " enter " + element); });
		//}

		visitRegion(region: Region, deepHistoryAbove: boolean) {
			var regionBehaviour = this.behaviour(region);

			// chain initiaisation of child vertices
			region.vertices.forEach(vertex => { vertex.accept(this, deepHistoryAbove || (region.initial && region.initial.kind === PseudoStateKind.DeepHistory)); });

			// leave the curent active child state when exiting the region
			regionBehaviour.leave.push((message, stateMachineInstance, history) => {
				invoke(this.behaviour(stateMachineInstance.getCurrent(region)).leave, message, stateMachineInstance); // NOTE: current state needs to be evaluated at runtime
			});

			// enter the appropriate initial child vertex when entering the region
			if (deepHistoryAbove || !region.initial || region.initial.isHistory()) { // NOTE: history needs to be determined at runtime
				regionBehaviour.endEnter.push((message, stateMachineInstance, history) => {
					var initial: Vertex = region.initial;

					if (history || region.initial.isHistory()) {
						initial = stateMachineInstance.getCurrent(region) || region.initial;
					}

					invoke(this.behaviour(initial).enter, message, stateMachineInstance, history || region.initial.kind === PseudoStateKind.DeepHistory);
				});
			} else {
				regionBehaviour.endEnter = regionBehaviour.endEnter.concat(this.behaviour(region.initial).enter);
			}

			// add element behaviour (debug)
			this.visitElement(region, deepHistoryAbove);
			
			// merge begin and end enter behaviour
			regionBehaviour.enter = regionBehaviour.beginEnter.concat(regionBehaviour.endEnter);
		}

		visitVertex(vertex: Vertex, deepHistoryAbove: boolean) {
			// add element behaviour (debug)
			this.visitElement(vertex, deepHistoryAbove);

			// evaluate comppletion transitions once vertex entry is complete
			this.behaviour(vertex).endEnter.push((message, stateMachineInstance, history) => {
				if (isComplete(vertex, stateMachineInstance)) {
					vertex.accept(Evaluator.instance, stateMachineInstance, vertex);
				}
			});
		}

		visitPseudoState(pseudoState: PseudoState, deepHistoryAbove: boolean) {
			var pseudoStateBehaviour = this.behaviour(pseudoState);
			
			// add vertex behaviour (debug and testing completion transitions)
			this.visitVertex(pseudoState, deepHistoryAbove);

			// terminate the state machine instance upon transition to a terminate pseudo state
			if (pseudoState.kind === PseudoStateKind.Terminate) {
				pseudoStateBehaviour.enter.push((message, stateMachineInstance, history) => {
					stateMachineInstance.isTerminated = true;
				});
			}

			// merge begin and end enter behaviour
			pseudoStateBehaviour.enter = pseudoStateBehaviour.beginEnter.concat(pseudoStateBehaviour.endEnter);
		}

		visitState(state: State, deepHistoryAbove: boolean) {
			var stateBehaviour = this.behaviour(state);

			state.regions.forEach(region => {
				var regionBehaviour = this.behaviour(region);

				// chain initiaisation of child regions
				region.accept(this, deepHistoryAbove);

				// leave child regions when leaving the state
				stateBehaviour.leave = stateBehaviour.leave.concat(regionBehaviour.leave);

				// enter child regions when entering the state
				stateBehaviour.endEnter = stateBehaviour.endEnter.concat(regionBehaviour.enter);
			});

			// add vertex behaviour (debug and testing completion transitions)
			this.visitVertex(state, deepHistoryAbove);

			// add the user defined behaviour when entering and exiting states
			stateBehaviour.leave = stateBehaviour.leave.concat(state.exitBehavior);
			stateBehaviour.beginEnter = stateBehaviour.beginEnter.concat(state.entryBehavior);

			// update the parent regions current state
			stateBehaviour.beginEnter.push((message, stateMachineInstance, history) => {
				if (state.region) {
					stateMachineInstance.setCurrent(state.region, state);
				}
			});

			// merge begin and end enter behaviour
			stateBehaviour.enter = stateBehaviour.beginEnter.concat(stateBehaviour.endEnter);
		}

		visitStateMachine(stateMachine: StateMachine, deepHistoryAbove: boolean) {
			this.visitState(stateMachine, deepHistoryAbove);

			// initiaise all the transitions once all the elements have been initialised
			stateMachine.accept(new InitialiseTransitions(), (element: Element) => { return this.behaviour(element); });

			// define the behaviour for initialising a state machine instance
			stateMachine.onInitialise = this.behaviour(stateMachine).enter;
		}
	}